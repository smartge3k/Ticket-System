package de.uniba.rz.app.gRPC;

import de.uniba.rz.io.rpc.TicketRequest;
import de.uniba.rz.io.rpc.TicketResponse;
import de.uniba.rz.io.rpc.TicketServiceGrpc;
import de.uniba.rz.io.rpc.TicketServiceGrpc.TicketServiceStub;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.Status;
import io.grpc.StatusRuntimeException;
import io.grpc.stub.StreamObserver;
import java.util.concurrent.TimeUnit;

public class gRPCClient{
	private ManagedChannel channel;
	private TicketServiceGrpc.TicketServiceBlockingStub syncStub;
	private TicketServiceGrpc.TicketServiceStub asyncStub;

	public gRPCClient(String host, int port) {
		// there are different options possible to specify the underlying transport
		this(ManagedChannelBuilder.forAddress(host, port).usePlaintext());
	}

	public gRPCClient(ManagedChannelBuilder<?> channelBuilder) {
		this.channel = channelBuilder.build();
		// stubs are generated by the "protoc" tool (in our case during the gradle
		// build)
		this.syncStub = TicketServiceGrpc.newBlockingStub(this.channel);
		this.asyncStub = TicketServiceGrpc.newStub(this.channel);
	}

	public String requestToServer(String message) {
		TicketResponse response = null;
		try {
			TicketRequest request = TicketRequest.newBuilder().setRequestbyclient(message).build();
			response = this.syncStub.serverrequest(request);
		} catch (StatusRuntimeException e) {
			System.err.println("The server is unresponsive.");
			this.shutdown();
		}
		return response.getResponsebyserver();
	}

	public void shutdown() {
		if (!channel.isShutdown()) {
			System.out.println("Trying to shut down the client . . .");
			while (true) {
				try {
					channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);
					System.out.println("Client successfully shutdown!");
				} catch (InterruptedException e) {
					// no handling of the InterruptedException needed
				}
				break;
			}
		}
	}
}
